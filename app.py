import os
import tempfile
import json
import math
from flask import Flask, render_template, request, send_file, jsonify
import requests
from shapely.geometry import Polygon, Point
from shapely.ops import unary_union
import numpy as np

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

def get_osm_buildings(bbox):
    """
    Fetch building data from Overpass API
    bbox: [west, south, east, north]
    """
    overpass_url = "http://overpass-api.de/api/interpreter"
    
    overpass_query = f"""
    [out:json][timeout:30];
    (
      way["building"]({bbox[1]},{bbox[0]},{bbox[3]},{bbox[2]});
      relation["building"]({bbox[1]},{bbox[0]},{bbox[3]},{bbox[2]});
    );
    out geom;
    """
    
    try:
        response = requests.post(overpass_url, data={'data': overpass_query}, timeout=30)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        raise Exception(f"Failed to fetch OSM data: {str(e)}")

def lat_lon_to_meters(lat, lon, origin_lat, origin_lon):
    """Convert lat/lon to local meter coordinates"""
    # Earth radius in meters
    R = 6378137
    
    # Convert to radians
    lat_rad = math.radians(lat)
    lon_rad = math.radians(lon)
    origin_lat_rad = math.radians(origin_lat)
    origin_lon_rad = math.radians(origin_lon)
    
    # Calculate x, y in meters
    x = R * (lon_rad - origin_lon_rad) * math.cos(origin_lat_rad)
    y = R * (lat_rad - origin_lat_rad)
    
    return x, y

def simplify_polygon(coords, tolerance=0.5):
    """Simplify polygon to reduce vertex count"""
    if len(coords) < 4:
        return coords
    
    polygon = Polygon(coords)
    simplified = polygon.simplify(tolerance, preserve_topology=True)
    
    if simplified.geom_type == 'Polygon':
        return list(simplified.exterior.coords)[:-1]  # Remove duplicate last point
    else:
        return coords[:-1] if coords[0] == coords[-1] else coords

def create_obj_from_buildings(buildings_data, building_height, quality, bbox):
    """
    Convert OSM building data to clean OBJ format with better geometry handling
    """
    obj_lines = [
        "# 3D Buildings exported from OpenStreetMap",
        "# Generated by OSM 3D Map Exporter",
        "# Optimized for simulation projects",
        ""
    ]
    
    # Calculate origin point (center of bbox for better precision)
    origin_lat = (bbox[1] + bbox[3]) / 2
    origin_lon = (bbox[0] + bbox[2]) / 2
    
    vertex_count = 0
    building_count = 0
    
    # Quality settings
    simplification_tolerance = {
        'low': 2.0,      # More aggressive simplification
        'medium': 1.0,    # Moderate simplification
        'high': 0.3      # Minimal simplification
    }.get(quality, 1.0)
    
    # Minimum building area threshold (square meters)
    min_area_threshold = {
        'low': 25.0,     # Skip very small buildings
        'medium': 10.0,   # Skip tiny buildings
        'high': 5.0      # Keep most buildings
    }.get(quality, 10.0)
    
    processed_buildings = []
    
    for element in buildings_data.get('elements', []):
        if element.get('type') != 'way' or 'geometry' not in element:
            continue
            
        # Extract coordinates
        coords = [(node['lon'], node['lat']) for node in element['geometry']]
        
        if len(coords) < 4:  # Need at least 3 points + closing point
            continue
            
        # Remove duplicate last point if it's the same as first
        if coords[0] == coords[-1]:
            coords = coords[:-1]
            
        if len(coords) < 3:
            continue
        
        try:
            # Convert to local coordinate system
            local_coords = []
            for lon, lat in coords:
                x, y = lat_lon_to_meters(lat, lon, origin_lat, origin_lon)
                local_coords.append((x, y))
            
            # Check building area
            polygon = Polygon(local_coords)
            if not polygon.is_valid or polygon.area < min_area_threshold:
                continue
            
            # Simplify polygon based on quality setting
            simplified_coords = simplify_polygon(local_coords, simplification_tolerance)
            
            if len(simplified_coords) < 3:
                continue
            
            # Get building height from OSM tags
            tags = element.get('tags', {})
            height = building_height
            
            if 'building:height' in tags:
                try:
                    height_str = tags['building:height'].replace('m', '').replace(' ', '')
                    height = max(float(height_str), 2.0)  # Minimum 2m height
                except:
                    pass
            elif 'building:levels' in tags:
                try:
                    levels = int(tags['building:levels'])
                    height = max(levels * 3.5, 2.0)  # 3.5m per level, minimum 2m
                except:
                    pass
            elif 'height' in tags:
                try:
                    height_str = tags['height'].replace('m', '').replace(' ', '')
                    height = max(float(height_str), 2.0)
                except:
                    pass
            
            # Add some randomization for visual variety if using default height
            if height == building_height and building_height == 10:
                import random
                height = random.uniform(8, 15)
            
            processed_buildings.append({
                'coords': simplified_coords,
                'height': height,
                'tags': tags
            })
            
        except Exception as e:
            continue
    
    # Generate OBJ geometry
    for building in processed_buildings:
        coords = building['coords']
        height = building['height']
        
        # Create base vertices (ground level - slightly below 0 for better ground contact)
        base_vertices = []
        for x, y in coords:
            obj_lines.append(f"v {x:.3f} {y:.3f} -0.1")
            base_vertices.append(vertex_count + 1)
            vertex_count += 1
        
        # Create top vertices (roof level)
        top_vertices = []
        for x, y in coords:
            obj_lines.append(f"v {x:.3f} {y:.3f} {height:.3f}")
            top_vertices.append(vertex_count + 1)
            vertex_count += 1
        
        n_vertices = len(coords)
        
        # Add object group for organization
        building_count += 1
        obj_lines.append(f"g building_{building_count}")
        
        # Bottom face (ground) - reverse winding for correct normal
        if n_vertices >= 3:
            face_indices = [str(base_vertices[i]) for i in reversed(range(n_vertices))]
            obj_lines.append(f"f {' '.join(face_indices)}")
        
        # Top face (roof) - correct winding for upward normal
        if n_vertices >= 3:
            face_indices = [str(top_vertices[i]) for i in range(n_vertices)]
            obj_lines.append(f"f {' '.join(face_indices)}")
        
        # Side faces (walls) - create quads for each wall
        for i in range(n_vertices):
            next_i = (i + 1) % n_vertices
            
            # Create quad face (counter-clockwise winding for outward normal)
            v1 = base_vertices[i]       # bottom current
            v2 = base_vertices[next_i]  # bottom next  
            v3 = top_vertices[next_i]   # top next
            v4 = top_vertices[i]        # top current
            
            obj_lines.append(f"f {v1} {v2} {v3} {v4}")
    
    # Add summary comments
    obj_lines.extend([
        "",
        f"# Summary:",
        f"# Total buildings: {building_count}",
        f"# Total vertices: {vertex_count}",
        f"# Quality level: {quality}",
        f"# Coordinate origin: {origin_lat:.6f}, {origin_lon:.6f}",
        ""
    ])
    
    return '\n'.join(obj_lines)

@app.route('/export_obj', methods=['POST'])
def export_obj():
    data = request.json
    bbox = data.get('bbox')  # [west, south, east, north]
    building_height = data.get('building_height', 10)
    quality = data.get('quality', 'medium')
    
    if not bbox or len(bbox) != 4:
        return jsonify({'error': 'Invalid bounding box'}), 400
    
    # Validate bbox
    west, south, east, north = bbox
    if west >= east or south >= north:
        return jsonify({'error': 'Invalid bounding box coordinates'}), 400
    
    # Check area size (prevent too large requests)
    area_deg = (east - west) * (north - south)
    if area_deg > 0.01:  # Roughly 1km x 1km at equator
        return jsonify({'error': 'Selected area too large. Please select a smaller area (max 1kmÂ²).'}), 400
    
    try:
        # Fetch building data from OSM
        buildings_data = get_osm_buildings(bbox)
        
        elements = buildings_data.get('elements', [])
        if not elements:
            return jsonify({'error': 'No buildings found in selected area. Try a different location or larger area.'}), 404
        
        # Filter for actual buildings with geometry
        valid_buildings = [e for e in elements if e.get('type') == 'way' and 'geometry' in e and len(e['geometry']) >= 4]
        if not valid_buildings:
            return jsonify({'error': 'No valid building geometries found in selected area.'}), 404
        
        # Generate OBJ content with improved geometry
        obj_content = create_obj_from_buildings(buildings_data, building_height, quality, bbox)
        
        # Create temporary file
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.obj', encoding='utf-8') as tmp_file:
            tmp_file.write(obj_content)
            tmp_file_path = tmp_file.name
        
        # Generate descriptive filename
        center_lat = (south + north) / 2
        center_lon = (west + east) / 2
        filename = f"osm_3d_buildings_{center_lat:.4f}_{center_lon:.4f}_{quality}.obj"
        
        return send_file(
            tmp_file_path, 
            as_attachment=True, 
            download_name=filename,
            mimetype='application/octet-stream'
        )
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        # Clean up temp file
        try:
            if 'tmp_file_path' in locals():
                os.unlink(tmp_file_path)
        except:
            pass

if __name__ == '__main__':
    app.run(debug=True, port=5000)